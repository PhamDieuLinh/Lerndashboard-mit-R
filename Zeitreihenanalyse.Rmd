---
title: "Zeitreihenanalyse"
author: "Dieu Linh Pham"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  learnr::tutorial:
    progressive: true
runtime: shiny
email: "Dieu.Pham@Student.HTW-Berlin.de"
resource_files:
- renv.lock
---

```{r setup, include=FALSE} 
library(rsconnect)
library(learnr)
library(gradethis)
library(shiny)
library(ggplot2)
library(dplyr)
library(readr)
library(plotly)
library(lubridate)
library(imputeTS)
library(tibble)

if (isTRUE(getOption("tutorial.runtime", "") == "shiny")) {
  gradethis_setup()
}

rmarkdown::find_pandoc(cache = FALSE)
knitr::opts_chunk$set(echo = FALSE)


hanoi <- read_csv("hanoi_temp.csv", show_col_types = FALSE)

hanoi <- hanoi %>%
  select(date, tavg) %>%
  mutate(date = as.Date(date, format = "%Y%j"),
         city = "Hanoi") %>%
  rename(temperature = tavg)

manila <- read_csv("manila_temp.csv", show_col_types = FALSE) %>%
  select(date, tavg) %>%
  mutate(date = as.Date(date, format = "%Y%j"),
         city = "Manila") %>%
  rename(temperature = tavg)

tokyo <- read_csv("tokyo_temp.csv", show_col_types = FALSE) %>%
  select(date, tavg) %>%
  mutate(date = as.Date(date, format = "%Y%j"),
         city = "Tokyo") %>%
  rename(temperature = tavg)

all_temp <- bind_rows(hanoi, manila, tokyo)

benzinpreis <- read_csv("tankerkoenigSoSe2025.csv", show_col_types = FALSE)

hanoi_mit_zeitna <- readr::read_delim("hanoi_w_na.csv", delim = ";", show_col_types = FALSE) %>%
  select(date, tavg) %>%
  mutate(date = as.Date(date, format = "%Y%j")) %>%
  rename(temperature = tavg)

hanoi_mit_na <- readr::read_delim("hanoi_w_na_1.csv", delim = ";", show_col_types = FALSE) %>%
  select(date, tavg) %>%
  mutate(date = as.Date(date, format = "%Y%j")) %>%
  rename(temperature = tavg)
```


## Ausgangsproblem


#### Das Problem


Stell dir vor, du planst mit zwei Freund:innen eine Reise nach Asien fÃ¼r 2 Monate. Jeder hat ein Reiseziel vorgeschlagen â€“ zur Auswahl stehen:

- ğŸŒ† **Hanoi (Vietnam)**
- ğŸ—¼ **Tokio (Japan)**
- ğŸï¸ **Manila (Philippinen)**

Das Wetter kÃ¶nnte ein entscheidender Faktor fÃ¼r eure Entscheidung sein. Eine Person in der Gruppe ist hitzeempfindlich und das Wetter spielt also eine zentrale Rolle.
Um die angenehmste Stadt fÃ¼r eure Reise auszuwÃ¤hlen, mÃ¶chtest du herausfinden: ğŸ§  Welche Stadt eignet sich besonders gut und zu welchem Zeitpunkt ist das Klima dort am angenehmsten?


```{r}
dateRangeInput("datumsbereich", "Zeitraum:",
               start = min(all_temp$date),
               end = max(all_temp$date),
               min = min(all_temp$date),
               max = max(all_temp$date),
               format = "dd.mm.yyyy",
               separator = " bis ")
```

```{r}
output$temp <- renderPlot({
  gefilterte_daten <- all_temp %>%
    filter(date >= input$datumsbereich[1],
           date <= input$datumsbereich[2])
  
  ggplot(gefilterte_daten, aes(x = date, y = temperature, color = city)) +
    geom_line() +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(title = "Durchschnittliche Temperatur in Hanoi, Manila und Tokyo",
         x = "Datum", y = "Temperatur (Â°C)", color = "Stadt") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
})
```

```{r}
plotOutput("temp")
```

Du hast tÃ¤gliche Temperaturdaten von 2020 bis Juni 2025 fÃ¼r alle 3 StÃ¤dte. Nun stellst du dir folgende Fragen:

 - Wie sieht das typische Wetter in jeder Stadt aus?
 - Welche Stadt zeigt regelmÃ¤ÃŸige Muster Ã¼ber die Jahre und wo gibt es viele Schwankungen?
 - LÃ¤sst sich eine Vorhersage fÃ¼r dieses Jahr erstellen, basierend auf den vergangenen Daten?
 - Welche Stadt ist also die beste Wahl fÃ¼r eine angenehme Reisezeit?

### ğŸ§  Lernziel

Ziel dieses Dashboards ist es, dich spielerisch und interaktiv mit den Grundlagen der Zeitreihenanalyse vertraut zu machen:

- Was ist eine Zeitreihe?
- Welche Bestandteile (Trend, SaisonalitÃ¤t, Rauschen) gibt es?
- Und: Welche Stadt wÃ¼rdest du empfehlen und wann wÃ¼rdest du reisen?


In nÃ¤chsten Abschnitte lernst du grundlegende Konzepte der Zeitreihenanalyse und wendest sie direkt auf das Problem deiner Asienreise an.


## Zeitreihe
Eine Zeitreihe ist eine Sammlung von Beobachtungen, die fortlaufend Ã¼ber die Zeit hinweg erhoben wurden.
Die Zeitreihenanalyse ist ein spezieller Ansatz zur Untersuchung von Daten, die Ã¼ber einen bestimmten Zeitraum hinweg in gleichmÃ¤ÃŸigen AbstÃ¤nden erhoben wurden.

In diesem Fall analysieren wir eine Zeitreihe von **tÃ¤glichen Durchschnittstemperaturen** fÃ¼r drei StÃ¤dte in Asien zwischen Januar 2020 und Juni 2025. Im folgenden Diagramm kannst du selbst auswÃ¤hlen, welche StÃ¤dte du analysieren mÃ¶chtest. Beobachte die Linien, erkenne mÃ¶gliche Muster oder Unterschiede zwischen den StÃ¤dten:

```{r}
checkboxGroupInput("stadt_auswahl", "StÃ¤dte auswÃ¤hlen:",
                   choices = unique(all_temp$city),
                   selected = unique(all_temp$city))

```

```{r}
output$temp_city <- renderPlotly({
  gefilterte_daten <- all_temp %>%
    filter(city %in% input$stadt_auswahl)

  p <- ggplot(gefilterte_daten, aes(x = date, y = temperature, color = city)) +
    geom_line() +
    labs(title = "Temperatur-Zeitreihe",
         x = "Datum", y = "Temperatur (Â°C)", color = "Stadt") +
    theme_minimal()

  ggplotly(p)
})
```

```{r}
h4("ğŸŒ¡ï¸ Temperaturverlauf nach Stadtwahl")
plotlyOutput("temp_city")
```



```{r erkennenquestion}
question("Sieht es so aus, als ob es ein sich wiederholendes Muster gibt?",
    answer("ja", correct = TRUE, message = "Ja, sehr gut beobachtet! Und es gibt auch einen leichten Anstieg der Temperaturen Ã¼ber die Jahre"),
    answer("nein", message = "ÃœberprÃ¼fe nochmals die Daten, vielleicht Ã¼ber lÃ¤ngeren Zeitraum."),
  allow_retry = TRUE
)
```

## Behandlung von fehlenden Werten

Ein hÃ¤ufig auftretendes Problem bei Zeitreihendaten sind fehlende Werte. Sie:

- verfÃ¤lschen statistische Eigenschaften,

- reduzieren die Nutzbarkeit der Daten fÃ¼r Auswertungen,

- und beeintrÃ¤chtigen besonders in der Zeitreihenmodellierung die FÃ¤higkeit, zeitliche AbhÃ¤ngigkeiten korrekt zu erfassen.

Dadurch kann die QualitÃ¤t von Analysen und Prognosen erheblich beeintrÃ¤chtigt werden.

___
FALL 1: fehlende Werte

Die folgende Zeitreihe zeigt die durchschnittliche Temperatur (in Â°C) von Januar 2025 bis Mai 2025 in Hanoi und enthÃ¤lt bewusst fehlende Werte (NA). 

```{r}
output$na_hanoi <- renderPlot({
  ggplot(hanoi_mit_na, aes(x = date, y = temperature)) +
    geom_line() +
    labs(title = "Temperatur-Zeitreihe mit NA",
         x = "Datum", y = "Temperatur (Â°C)") +
    theme_minimal()
}, height = 400, width = 600)
```

```{r}
plotOutput("na_hanoi")
```


Zu den einfachen Methoden gehÃ¶ren das Ignorieren der fehlenden Werte, das LÃ¶schen unvollstÃ¤ndiger Beobachtungen.

```{r na_question}
question("Was passiert, wenn du NA-Zeilen einfach aus einer Zeitreihe entfernst?",
    answer("Es kann zu Verzerrungen in der Analyse fÃ¼hren", correct = TRUE,
         message = "Richtig! Ignorieren und LÃ¶schen zeigen sich oft als ungeeignet, da sie zu Verlusten an Informationsgehalt und einer Verschlechterung der Analyseergebnisse fÃ¼hren kÃ¶nnen."),
  answer("Das LÃ¶schen verbessert die Genauigkeit", message = "Ganz im Gegenteil â€” es kann die Genauigkeit verringern."),
  answer("Fehlende Werte beeinflussen Zeitreihenmodelle nicht", message = "Doch â€“ Zeitreihenmodelle setzen oft vollstÃ¤ndige Daten voraus."),
  allow_retry = TRUE
)
```

Eine praktikable LÃ¶sung stellt die sogenannte Mittelwertimputation dar. Fehlende Werte werden durch einen Gesamtmittelwert ersetzt.

Nutze die Funktion na_mean() aus dem Paket imputeTS um die fehlenden Werte zu ersetzen.

```{r na_exercise, exercise=TRUE}
# Verwende den vorbereiteten Dataset `hanoi_mit_na` und die Spalte `temperature`
hanoi_filled <- NULL
ggplot_na_imputations(hanoi_mit_na$temperature, hanoi_filled)
invisible(hanoi_filled)
```

```{r na_exercise-check}
grade_this({
  expected <- na_mean(hanoi_mit_na$temperature)
  
  if (is.numeric(.result) &&
      isTRUE(all.equal(.result, expected))) {
    pass("Sehr gut! Du hast die fehlenden Werte korrekt mit `na_mean()` aufgefÃ¼llt.")
  } else {
    fail("Bitte wende `na_mean()` korrekt auf die Spalte `temperature` an und speichere das Ergebnis in `hanoi_filled`.")
  }
})
```

::: {#na_exercise-hint}
Benutze nur die Spalte 'temperature'.
:::

```{r na_question_2}
question("Was hÃ¤ltst du von der Imputation mit `na_mean()` fÃ¼r Temperatur-Zeitreihen?",
  answer("Sie ist eine gute Wahl, weil sie einfach und schnell ist.", correct = FALSE,
         message = "Nicht ganz, einfache Methoden sind nicht immer passend."),
  answer("Sie ist ungeeignet, weil sie keine Trends oder SaisonalitÃ¤t berÃ¼cksichtigt.", correct = TRUE, message = "Richtig! `na_mean()` setzt fÃ¼r alle fehlenden Werte denselben Mittelwert ein. Dadurch wird der natÃ¼rliche Verlauf der Zeitreihe gestÃ¶rt: die eingefÃ¼gten Werte folgen weder dem Trend noch den saisonalen Mustern und haben oft alle denselben y-Wert.Das kann die Analyse oder Vorhersage erheblich verfÃ¤lschen."),
  answer("Sie erzeugt Zufallswerte und ist deshalb unzuverlÃ¤ssig.", correct = FALSE,
         message = "Nein, `na_mean()` ersetzt NAs durch einen konstanten Mittelwert, nicht zufÃ¤llig."),
  answer("Sie erhÃ¶ht die Varianz der Zeitreihe.", correct = FALSE,
         message = "Im Gegenteil, sie reduziert oft die Varianz."),
  allow_retry = TRUE
)
```

na_mean()
- âœ… Sehr einfach und schnell
- âš ï¸ Geringe Genauigkeit bei vielen Zeitreihen
- ğŸš« Keine BerÃ¼cksichtigung zeitlicher Strukturen
- ğŸ“‰ FÃ¼hrt oft zu reduzierter Varianz

Eine andere Methode ist lineare Interpolation. Im ersten Schritt wird die saisonale Komponente von der Zeitreihe getrennt. AnschlieÃŸend erfolgt die Imputation auf der verbleibenden (nicht-saisonalen) Komponente mittels linearer Interpolation. Danach wird die saisonale Komponente wieder hinzugefÃ¼gt.
Diese Methode eignet sich besonders gut fÃ¼r Zeitreihen mit klarer und ausgeprÃ¤gter SaisonalitÃ¤t.

Die Funktion na_interpolation gehÃ¶rt jedoch zu den AnsÃ¤tzen, die in der Regel sehr gute Ergebnisse liefern und sich besonders dann eignen, wenn eine genauere Ersetzung fehlender Werte erforderlich ist.

Nutze jetzt die Funktion na_interpolation() aus dem Paket imputeTS um die fehlenden Werte zu ersetzen.

```{r na_exercise_2, exercise=TRUE}
# Verwende den vorbereiteten Dataset `hanoi_mit_na` und die Spalte `temperature`
hanoi_filled <- NULL
ggplot_na_imputations(hanoi_mit_na$temperature, hanoi_filled)
invisible(hanoi_filled)
```

```{r na_exercise_2-check}
grade_this({
  expected <- na_interpolation(hanoi_mit_na$temperature)
  
  if (is.numeric(.result) &&
      isTRUE(all.equal(.result, expected))) {
    pass("Sehr gut! Du hast die fehlenden Werte korrekt mit `na_mean()` aufgefÃ¼llt.")
  } else {
    fail("Bitte wende `na_interpolation()` korrekt auf die Spalte `temperature` an und speichere das Ergebnis in `hanoi_filled`.")
  }
})
```

::: {#na_exercise_2-hint}
Benutze nur die Spalte 'temperature'.
:::

___
FALL 2: fehlender Zeitstempel

Sieh dir die Zeitreihe unten genau an und zoome hinein, um zu Ã¼berprÃ¼fen, ob einzelne Zeitpunkte in der Datenreihe fehlen. In der Tabelle rechts siehst du einen Auszug der Originaldaten. Dort kannst du erkennen, welche Datenpunkte existieren und indirekt auch sehen, welche Tage vollstÃ¤ndig fehlen.

```{r}
output$zeitna_hanoi <- renderPlotly({
  p <- ggplot(hanoi_mit_zeitna, aes(x = date, y = temperature)) +
    geom_line() +
    labs(title = "Temperatur-Zeitreihe mit NA",
         x = "Datum", y = "Temperatur (Â°C)") +
    theme_minimal()
  
  ggplotly(p)
})
```

```{r}
output$na_table_hanoi <- renderTable({
   hanoi_mit_zeitna %>%
    mutate(date = format(date, "%d.%m.%Y")) %>%
    head(15)
})
```

```{r}
fluidRow(
  column(width = 8,
         plotlyOutput("zeitna_hanoi")
  ),
  column(width = 3,
         tableOutput("na_table_hanoi")
  )
)
```

In R kann man mit dem Paket tibble eine vollstÃ¤ndige Zeitachse erstellen (z.B. mit seq() fÃ¼r tÃ¤gliche Daten) und diese anschlieÃŸend per left_join() mit der ursprÃ¼nglichen Zeitreihe verbinden. 

FÃ¼hre einfach den folgenden Code aus, um zu sehen, wie die fehlenden Zeitpunkte in der Zeitreihe ergÃ¤nzt wurden. FÃ¼hre den folgenden Code aus, um zu sehen, wie die fehlenden Zeitpunkte in der Zeitreihe ergÃ¤nzt wurden.
```{r na_exercise_3, exercise=TRUE}
full_dates <- tibble(date = seq(min(hanoi_mit_zeitna$date),
                                max(hanoi_mit_zeitna$date),
                                by = "day"))
hanoi_fixed <- full_dates %>%
  left_join(hanoi_mit_zeitna, by = "date")

ggplot(hanoi_fixed, aes(x = date, y = temperature)) +
  geom_line(color = "steelblue") +
  geom_point(data = filter(hanoi_fixed, is.na(temperature)),
             aes(x = date, y = temperature), color = "red", size = 2) +
  labs(title = "Temperatur-Zeitreihe mit fehlenden Zeitpunkten",
       x = "Datum", y = "Temperatur (Â°C)") +
  theme_minimal()
```

So werden fehlende Zeitpunkte, die im Originaldatensatz vollstÃ¤ndig gefehlt haben, wieder eingefÃ¼gt und mit NA markiert. AnschlieÃŸend kÃ¶nnen die entstandenen NA-Werte mit den oben genannten Imputationsmethoden aufgefÃ¼llt werden.

## Komponenten einer Zeitreihe
Zeitreihen bestehen oft aus folgenden Komponenten:

- ğŸ“ˆ **Trend** â€“ langfristige Entwicklung der Werte Ã¼ber einen lÃ¤ngeren Zeitraum (steigen, fallen oder gleich bleiben)
- ğŸ” **Saisonale Schwankung** â€“ regelmÃ¤ÃŸige Muster innerhalb eines Jahres, z.B. durch Jahreszeiten oder Feiertage
- **Zyklen** â€“ mehrjÃ¤hrige, wellenartige Schwankungen, die meist wirtschaftliche Auf- und AbschwÃ¼nge widerspiegeln
- ğŸ² **ZufÃ¤lliges Rauschen** â€“ kleine EinflÃ¼sse, die stÃ¤ndig auftreten


Die Unterscheidung zwischen Trend und Zyklus ist bis zu einem gewissen Grad kÃ¼nstlich, daher fassen die meisten Zerlegungsverfahren diese beiden Komponenten zu einer einzigen zusammen. Die wird in der Literatur hÃ¤ufig als Trend-Zyklus Komponente bezeichnet und in der grafischen Zerlegung der Zeitreihe erscheint die Komponente als Trend.


```{r}
output$decomp_plot <- renderPlot({
  df <- benzinpreis %>%
    filter(id == "005056ba-7cb6-1ee5-b187-bc79c0a8d9ec") %>%
    mutate(
      datetime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M:%S")
    ) %>%
    arrange(datetime) %>%
    filter(!is.na(datetime), !is.na(e10_median)) %>%
    filter(
      datetime >= min(datetime) + lubridate::weeks(2),
      datetime <  min(datetime) + lubridate::weeks(4)
    )

  ts_data <- ts(df$e10_median, frequency = 24)

  stl_result <- stl(ts_data, s.window = "periodic")
  plot(stl_result, main = "STL-Dekomposition der E10-Preise stÃ¼ndlich Woche 3-4")
})
```

```{r}
plotOutput("decomp_plot")
```


Die dargestellten Daten zeigen stÃ¼ndlich gemessene E10-Benzinpreise an einer ausgewÃ¤hlten Tankstelle Ã¼ber einen bestimmten Zeitraum. In diesem Plot wird ein Ausschnitt von Woche 3 bis Woche 4 nach Beginn der Aufzeichnung betrachtet.

## Trendbestimmung
- Gleitende Durchschnitt (Moving Average):

Eine der einfachsten Methoden zur GlÃ¤ttung von Zeitreihen besteht in der Berechnung sogenannter gleitender Durchschnitte. Dabei wird versucht, den zugrunde liegenden Trend einer Zeitreihe zu schÃ¤tzen, indem man lokale Mittelwerte bildet.

Ein gleitender Durchschnitt der Ordnung $m$ wird folgendermaÃŸen definiert:

$$
\hat{T}_t = \frac{1}{m} \sum_{j = -k}^{k} y_{t + j}, \quad \text{mit } m = 2k + 1 \
$$

Dabei wird der Wert der Trend zum Zeitpunkt $t$ als Durchschnitt der Zeitreihenwerte innerhalb eines symmetrischen Fensters von $k$ Perioden um $t$ berechnet. Da benachbarte Zeitpunkte meist Ã¤hnliche Werte aufweisen, werden durch diesen Durchschnitt zufÃ¤llige Schwankungen reduziert. Ãœbrig bleibt eine geglÃ¤ttete Darstellung des langfristigen Trends.  

Man spricht in diesem Fall von einem $m$-MA, also einem gleitenden Durchschnitt der Ordnung $m$.


```{r}
sliderInput("ma_window", "FenstergrÃ¶ÃŸe (Tage) fÃ¼r gleitenden Durchschnitt:",
            min = 5, max = 360, value = 30, step = 5)

```

```{r}
output$trend_plot <- renderPlotly({
  req(input$ma_window)  
  
  df <- all_temp %>%
    group_by(city) %>%
    arrange(date) %>%
    mutate(trend = zoo::rollmean(temperature, input$ma_window, fill = NA, align = "center"))

  p <- ggplot(df, aes(x = date)) +
    geom_line(aes(y = temperature, color = city), alpha = 0.4) +
    geom_line(aes(y = trend, color = city), size = 1) +
    labs(title = "Trend mit Moving Average (fÃ¼r alle StÃ¤dte)",
         y = "Temperatur (Â°C)", x = "Datum", color = "Stadt") +
    theme_minimal()

  ggplotly(p)
})
```

```{r}
plotlyOutput("trend_plot")
```

```{r trend_question}
question_text("Was passiert mit dem Trend, wenn du die FenstergrÃ¶ÃŸe erhÃ¶hst?",
    answer("glatter", correct = TRUE, message = "Sehr gut beobachtet! Eine grÃ¶ÃŸere FenstergrÃ¶ÃŸe fÃ¼hrt zu stÃ¤rkerer GlÃ¤ttung."),
  allow_retry = TRUE,
  placeholder = 'Antworte mit 1 Wort'
)
```

```{r trend_question2}
question("Wie wÃ¼rdest du den Temperaturtrend anhand der gleitenden Durchschnittskurve beschreiben?",
  answer("Er steigt Ã¼ber die Zeit hinweg langsam an", correct = TRUE),
  answer("Er bleibt konstant ohne erkennbaren Verlauf", message = "ÃœberprÃ¼fe nochmal die Trendlinie. Zeigt sie VerÃ¤nderung?"),
  answer("Er fÃ¤llt abrupt mehrfach ab"),
  allow_retry = TRUE
)
```

- Lokale Regression (LOESS : Locally Estimated Scatterplot Smoothing)

ist eine Methode zur TrendglÃ¤ttung, bei der nicht der Durchschnitt benachbarter Punkte berechnet wird, sondern lokale Geraden an Abschnitte der Zeitreihe angepasst werden.

Ein bekanntes Verfahren dafÃ¼r ist Loess und basiert auf lokaler linearer GlÃ¤ttung, ist jedoch so konzipiert, dass AusreiÃŸer oder ungewÃ¶hnliche Beobachtungen weniger Einfluss auf die Trendlinie haben. Dadurch liefert die Loess-Kurve eine robustere Darstellung des Trends, selbst bei untypischen Datenpunkten.

```{r}
sliderInput("loess_span", "GlÃ¤ttungsgrad (LOESS span):",
            min = 0.025, max = 0.5, value = 0.2, step = 0.01)
```

```{r}
output$loess_plot <- renderPlotly({
 
  df_smoothed <- all_temp %>%
    group_by(city) %>%
    arrange(date) %>%
    mutate(loess_fit = loess(temperature ~ as.numeric(date), span = input$loess_span)$fitted)


  p <- ggplot(df_smoothed, aes(x = date)) +
    geom_line(aes(y = temperature, color = city), alpha = 0.4) +
    geom_line(aes(y = loess_fit, color = city), size = 1) +
    labs(title = "LOESS-GlÃ¤ttung der Temperaturzeitreihen",
         x = "Datum", y = "Temperatur (Â°C)", color = "Stadt") +
    theme_minimal()

  ggplotly(p)
})


```

```{r}
plotlyOutput("loess_plot")
```

## LÃ¤nge einer SaisonalitÃ¤t

In einer Zeitreihe beschreibt die SaisonalitÃ¤t regelmÃ¤ÃŸig wiederkehrende Muster. Die LÃ¤nge der SaisonalitÃ¤t gibt an, nach wie vielen Zeitpunkten sich dieses Muster wiederholt.

##### Beispiel
In diesem Diagramm siehst du die durchschnittlichen E10-Preise einer ausgewÃ¤hlten Tankstelle Ã¼ber eine bestimmte zeitliche AuflÃ¶sung hinweg.

- Graue Punkte zeigen alle einzelnen Preisbeobachtungen (inkl. AusreiÃŸer).

- Die blaue Linie stellt den durchschnittlichen (median) Preis fÃ¼r jede Zeitkategorie dar, z.â€¯B. fÃ¼r jede Stunde oder jeden Wochentag.


```{r}
selectInput("zeit_aggregation", "Zeitliche AuflÃ¶sung:",
             choices = c("Stunde", "Wochentag"),
            selected = "Stunde")
```

```{r}
output$benzin_plot <- renderPlot({
  df <- benzinpreis %>%
    filter(id == "005056ba-7cb6-1ee5-b187-bc79c0a8d9ec") %>%
    mutate(
      datetime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M:%S"),
      hour = lubridate::hour(datetime),
      weekday = lubridate::wday(datetime, label = TRUE, week_start = 1)
    ) %>%
    filter(!is.na(hour)) 

  df$hour <- factor(df$hour, levels = 0:23) 

  xvar_col <- switch(input$zeit_aggregation,
                     "Stunde" = "hour",
                     "Wochentag" = "weekday")

  ggplot(df, aes(x = .data[[xvar_col]], y = e10_median)) +
    geom_point(alpha = 0.2, color = "gray") +
    stat_summary(aes(group = 1), fun = median, geom = "line", color = "steelblue", linewidth = 1) +
    labs(
      title = paste("E10-Preis nach", input$zeit_aggregation, "fÃ¼r die ausgewÃ¤hlte Station"),
      x = input$zeit_aggregation,
      y = "E10 Median Preis (EUR)"
    ) +
    theme_minimal()
})

```

```{r}
plotOutput("benzin_plot")
```


WÃ¤hle unterschiedliche zeitliche AuflÃ¶sungen im Dropdown-MenÃ¼ oben. Beobachte, ob es wiederkehrende Muster gibt.

```{r benzin_ss_question}
question("Zu welcher Tageszeit ist der durchschnittliche E10-Preis am hÃ¶chsten?",
  answer("Am frÃ¼hen Morgen (ca. 5â€“6 Uhr)", correct = TRUE, message = "Richtig â€“ es gibt einen deutlichen Preisanstieg am Morgen."),
  answer("Mittags", message = "Nicht ganz â€“ der Preis sinkt mittags eher leicht."),
  answer("Am spÃ¤ten Abend (ca. 22â€“23 Uhr)", message = "Nicht ganz â€“ der Preis steigt abends, aber nicht so stark."),
  random_answer_order = TRUE,
  allow_retry = TRUE
)
```


```{r benzin_ss_question_2}
question("Wie hÃ¤ufig wiederholt sich das saisonale Muster?",
  answer("Jeden Tag", correct = TRUE, message = "Richtig â€“ die Preisstruktur wiederholt sich innerhalb von 24 Stunden."),
  answer("Jede Woche"),
  answer("Einmal pro Monat"),
  allow_retry = TRUE
)
```

```{r benzin_ss_question_3}
question("Welche Art von SaisonalitÃ¤t erkennst du in der Grafik?",
  answer("TÃ¤gliche SaisonalitÃ¤t", correct = TRUE, message = "Richtig! Die Preisschwankungen folgen einem Tagesmuster."),
  answer("WÃ¶chentliche SaisonalitÃ¤t", message = "Nicht in dieser Grafik â€“ wir sehen Schwankungen innerhalb eines Tages."),
  answer("Monatliche SaisonalitÃ¤t", message = "Das ist hier nicht dargestellt."),
  allow_retry = TRUE
)
```


Hier ist die bereinigte SaisonalitÃ¤t dargestellt â€“ also das wiederkehrende Muster der E10-Preise im Tagesverlauf.


Im Gegensatz zum vorherigen Plot, der sowohl Trend als auch Streuung der Rohdaten zeigt, wurde hier der Trend entfernt und das SaisonalitÃ¤tsmuster Ã¼ber alle Tage hinweg geglÃ¤ttet. Dadurch lÃ¤sst sich der typische Tagesverlauf der Preise klarer erkennen, ohne durch AusreiÃŸer oder Schwankungen Ã¼berlagert zu werden.


```{r}
output$benzin_plot_2 <- renderPlotly({

  df <- benzinpreis %>%
    filter(id == "005056ba-7cb6-1ee5-b187-bc79c0a8d9ec") %>%
    mutate(datetime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M:%S")) %>%
    filter(!is.na(datetime)) %>%
    arrange(datetime)

  ts_price <- ts(df$e10_median, frequency = 24)

  stl_result <- stl(ts_price, s.window = "periodic")
  seasonal <- stl_result$time.series[, "seasonal"]
  seasonal_subset <- seasonal[1:(7 * 24)]  # first 7 days (24 hours * 7)

  plot_ly(
    x = 1:(7 * 24),
    y = seasonal_subset,
    type = "scatter",
    mode = "lines",
    line = list(color = "steelblue", width = 2)
  ) %>%
    layout(
      title = "Saisonale Komponente erste 7 Tage",
      xaxis = list(title = "Stunden"),
      yaxis = list(title = "SaisonalitÃ¤t")
    )
})
```

```{r}
plotlyOutput("benzin_plot_2")
```




##### ZurÃ¼ck zum Ausgangsproblem


Jetzt verstehst du, wie saisonale Muster in Daten sichtbar gemacht werden kÃ¶nnen, zum Beispiel bei Benzinpreisen, die sich im Tages oder Wochenverlauf regelmÃ¤ÃŸig Ã¤ndern. Doch wie sieht das bei Temperaturen aus?


```{r}
selectInput("stadt", "Stadt:", choices = unique(all_temp$city), selected = "Hanoi")

selectInput("zeit_temp_agg", "Zeitliche AuflÃ¶sung:",
            choices = c("Woche" = "week", "Monat" = "month", "Quartal" = "quarter"))

```


```{r}
output$temp_s_plot <- renderPlot({
  req(input$stadt, input$zeit_temp_agg)

  df <- all_temp %>%
    filter(city == input$stadt) %>%
    mutate(
      date = as.Date(date),
      weekday = lubridate::wday(date, label = TRUE, week_start = 1),
      month = lubridate::month(date),
      month_label = lubridate::month(date, label = TRUE),
      quarter_group = factor(case_when(
        month %% 4 == 1 ~ "M1-4-7-10",
        month %% 4 == 2 ~ "M2-5-8-11",
        month %% 4 == 3 ~ "M3-6-9-12",
        month %% 4 == 0 ~ "M4-8-12-3"  # optional, catch month = 12
      ), levels = c("M1-4-7-10", "M2-5-8-11", "M3-6-9-12", "M4-8-12-3"))
    )

  xvar <- switch(input$zeit_temp_agg,
                 "week" = df$weekday,
                 "month" = df$month_label,
                 "quarter" = df$quarter_group)

  ggplot(df, aes(x = xvar, y = temperature)) +
    geom_point(alpha = 0.2, color = "gray") +
    stat_summary(aes(group = 1), fun = median, geom = "line", color = "firebrick", linewidth = 1) +
    labs(
      title = paste("Temperaturverlauf nach", input$zeit_temp_agg, "in", input$stadt),
      x = tools::toTitleCase(input$zeit_temp_agg),
      y = "Temperatur (Â°C)"
    ) +
    theme_minimal()
})
```

```{r}
plotOutput("temp_s_plot")
```

```{r}
output$season_plot <- renderPlot({
df <- all_temp %>%
    filter(city == input$stadt) %>%
    mutate(
      year = year(date),
      month = month(date, label = TRUE)
    ) %>%
    group_by(year, month) %>%
    summarise(temp_avg = mean(temperature, na.rm = TRUE), .groups = "drop")

  ggplot(df, aes(x = month, y = temp_avg, group = year, color = as.factor(year))) +
    geom_line() +
    labs(title = "Saisonale Muster (Monatlich)",
         x = "Monat", y = "Durchschnittliche Temperatur",
         color = "Jahr") +
    theme_minimal()
})

```


Hier ist die bereinigte SaisonalitÃ¤t:


```{r}
output$season_plot_stl <- renderPlot({

  df <- all_temp %>%
    filter(city == input$stadt) %>%
    mutate(datetime = as.POSIXct(date)) %>%
    arrange(datetime)

   ts_temp <- ts(df$temperature, frequency = 365, start = c(2020, 1))  

  plot(stl(ts_temp, s.window = "periodic")$time.series[, "seasonal"],
       type = "l",
       col = "darkblue",
       lwd = 2,
       main = paste("Saisonale Temperaturkomponente fÃ¼r", input$stadt),
       xlab = "Tage", ylab = "SaisonalitÃ¤t")
})
```

```{r}
plotOutput("season_plot_stl")
```

```{r temp_ss_question}
question("Wie oft wiederholt sich das Temperaturniveau im Verlauf dieser Zeitreihe?",
  answer("Jede 12 Monate (jÃ¤hrlich)", message = "Richtig! jede Temperaturschwankung folgt einem Jahreszyklus.",correct = TRUE),
  answer("VierteljÃ¤hrlich", message = "Nicht ganz."),
  answer("Wochenlich", message = "Nicht ganz."),
  answer("UnregelmÃ¤ÃŸig", message = "Ãœberlege nochmal: Gibt es ein klares, wiederkehrendes Muster?"),
  allow_retry = TRUE
)
```

::: summary

```{r}
plotOutput("season_plot")
```

Die Grafik stellt die durchschnittliche monatliche Temperatur in den Jahren 2020 bis 2025 dar. Jede farbige Linie zeigt den Jahresverlauf fÃ¼r ein bestimmtes Jahr. Dabei wird deutlich, dass sich die Temperatur jedes Jahr nach einem Ã¤hnlichen Muster verÃ¤ndert
:::

## Dekomposition

Bevor wir Zeitreihen zerlegen, sollten wir verstehen, wie man eine Zeitreihe mathematisch modellieren kann.

___
â• Additives Modell

Im klassischen **additiven Modell** setzen sich die Bestandteile der Zeitreihe unabhÃ¤ngig voneinander zusammen:

\[
y_t = T_t + S_t + I_t
\]

- \( y_t \): beobachteter Wert zur Zeit \( t \)  
- \( T_t \): langfristiger Trend  
- \( S_t \): saisonale Schwankungen  
- \( I_t \): irregulÃ¤re, zufÃ¤llige EinflÃ¼sse

___
âœ–ï¸ Multiplikatives Modell

Wenn sich die Komponenten **gegenseitig beeinflussen**, ist ein **multiplikatives Modell** angemessener:

\[
y_t = T_t \cdot S_t \cdot I_t
\]

Hier hÃ¤ngen saisonale und zufÃ¤llige Abweichungen **proportional vom Trend ** ab.

â— Grenzen der klassischen Zerlegung

- Keine Trendwerte an Anfang/Ende verfÃ¼gbar: Der Trend wird mit einem gleitenden Durchschnitt berechnet. DafÃ¼r braucht man Werte vor und nach einem Zeitpunkt. Deshalb kann am Rand der Zeitreihe kein Trend berechnet werden
- Trend-Zyklus ist oft zu glatt: Schnelle Anstiege oder AbfÃ¤lle werden oft stark geglattet.
- Saisonale Muster verÃ¤ndern sich langfristig: Klassissche Verfahren gehen davon aus, dass sich das saisonale Muster jedes Jahr gleich wiederholt. In Wirklichkeit Ã¤ndern sich saisonale Effekte aber oft
- Empfindlich gegenÃ¼ber AusreiÃŸern: Die klassische Methode ist gegenÃ¼ber ungewÃ¶hnlichen Werten nicht robust

___
ğŸ” STL

Die **STL-Zerlegung** ist eine moderne, flexible und robuste Methode zur Zerlegung von Zeitreihen.  
STL steht fÃ¼r:
**S**easonal and **T**rend decomposition using **L**oess

Die STL-Zerlegung ist ausschlieÃŸlich additiv.


ğŸ§ª Deine Aufgabe: STL-Zerlegung selbst durchfÃ¼hren

Jetzt bist du dran! Verwende die Funktion `stl()`, um die Temperaturdaten einer Stadt in **Trend**, **SaisonalitÃ¤t** und **Restkomponente** zu zerlegen. Benutze  *s.window = "periodic" *.

ğŸ’¡ **Tipp:** Probiere gern zuerst `ts_tokyo` und `ts_manila` aus und vergleiche die Ergebnisse.  
â¡ï¸ FÃ¼r die Abgabe trage dann bitte die LÃ¶sung mit **`ts_hanoi`** ein.

```{r stl-setup, include=FALSE}
ts_hanoi <- ts(all_temp %>% filter(city == "Hanoi") %>% pull(temperature),
               frequency = 365, start = c(2020, 1))
ts_tokyo <- ts(all_temp %>% filter(city == "Tokyo") %>% pull(temperature),
               frequency = 365, start = c(2020, 1))

ts_manila <- ts(all_temp %>% filter(city == "Manila") %>% pull(temperature),
                frequency = 365, start = c(2020, 1))
```


```{r stl_exercise, exercise=TRUE, exercise.setup = "stl-setup"}
# Es gibt vorbereitete Zeitreihen `ts_hanoi`, `ts_tokyo`, `ts_manila`.
stl_result <- NULL
plot(stl_result)
invisible(stl_result)
```

```{r stl_exercise-check}
grade_this({
  if (!inherits(.result, "stl")) {
    fail("Bitte definiere `stl_result` mit der Funktion `stl()`.")
  }

  data_match <- isTRUE(all.equal(head(.result$time.series[, "trend"], 10),
                                 head(stl(ts_hanoi, s.window = "periodic")$time.series[, "trend"], 10)))

  if (data_match) {
    pass("Sehr gut! Du hast die Zeitreihe `ts_hanoi` korrekt zerlegt!")
  } else {
    fail("Bitte verwende die Zeitreihe `ts_hanoi` fÃ¼r deine Zerlegung.")
  }
})
```


___
ï¸â—In dieser Lernanwendung wird nur die additive STL-Zerlegung behandelt. STL ist eine vielseitige und robuste Methode zur Zerlegung von Zeitreihen, wurde jedoch speziell fÃ¼r additive Modelle entwickelt. Aus GrÃ¼nden der Klarheit und Fokussierung wird daher auf die additive Variante beschrÃ¤nkt.ï¸

Eine multiplikative Zerlegung lÃ¤sst sich durch Log-Transformation der Daten und anschlieÃŸende RÃ¼cktransformation der Komponenten durchfÃ¼hren. Zwischenformen von additiven und multiplikativen Zerlegungen kÃ¶nnen mithilfe der Box-Cox-Transformation realisiert werden.


## Auto-Korrelation

In Zeitreihen ist es hÃ¤ufig so, dass der heutige Wert mit vorherigen Werten zusammenhÃ¤ngt. Autokorrelation misst die lineare Beziehung zwischen zeitlich versetzten Werten einer Zeitreihe. 

Hohe Autokorrelationswerte bei bestimmten Lags kÃ¶nnen auf saisonale Muster oder wiederkehrende Strukturen in den Daten hinweisen.


```{r}
selectInput("stadt_lag", "Stadt auswÃ¤hlen:",
            choices = unique(all_temp$city),
            selected = "Hanoi")
selectInput("lag_days", "ZeitverzÃ¶gerung (Lag) wÃ¤hlen:",
            choices = c("1 Tag" = 1,
                        "1 Woche" = 7,
                        "1 Monat" = 30,
                        "1 Quartal" = 90,
                        "Halbes Jahr" = 182,
                        "1 Jahr" = 365),
            selected = 365)

```

```{r}

output$lag_plot <- renderPlot({

  df <- all_temp %>%
    filter(city == input$stadt_lag) %>%
    arrange(date) %>%
    mutate(lagged_temp = lag(temperature, as.integer(input$lag_days)))

  corr_val <- cor(df$temperature, df$lagged_temp, use = "complete.obs")

  ggplot(df, aes(x = lagged_temp, y = temperature)) +
    geom_point(alpha = 0.3) +
    geom_smooth(method = "lm", se = FALSE, color = "darkgreen") +
    labs(
      title = paste0("Lag-Plot: Temperatur(t) vs. Temperatur(t - k)"),
      subtitle = paste0("Korrelationswert: ", round(corr_val, 3)),
      x = "Temperatur bei t - k",
      y = "Temperatur bei t"
    ) +
    theme_minimal()
})


```

```{r}
plotOutput("lag_plot")
```

Der y- Wert eines Punktes ist der Wert der Original- Zeitreihe, der x-Wert derjenige der verschobenen Zeitreihe zu einem gewaÌˆhlten Zeitpunkt t-k.

Der Lag-Plot zeigt, wie stark die Temperatur an einem Tag mit der Temperatur k Tage zuvor zusammenhÃ¤ngt.  Ein hoher Korrelationswert zeigt starke Autokorrelation und kann auf ein wiederkehrendes Muster in der Zeitreihe hindeuten. Ein niedriger oder negativer Wert deutet auf schwache oder keine AbhÃ¤ngigkeit.

```{r lag_question}
question("Bei welchen der folgenden Lags ist die Korrelation in tÃ¤glichen Temperaturdaten typischerweise hoch? (Tipp: Es gibt **3 richtige Antworten**, bitte alle auswÃ¤hlen.)",
  answer("Lag 1", correct = TRUE),
  answer("Lag 7", correct = TRUE),
  answer("Lag 30", correct = FALSE),
  answer("Lag 365 (1 Jahr)", correct = TRUE),
  answer("Lag 90", correct = FALSE),
  answer("Lag 182 (halbes Jahr)", correct = FALSE),
  allow_retry = TRUE,
  random_answer_order = FALSE
)
```


```{r lag_question_2}
question("Warum zeigen tÃ¤gliche Temperaturdaten oft eine starke Korrelation bei Lag = 1 (vor 1 Tag) und 7 (vor 1 Woche), auch ohne echte Saison?",
  answer("Weil sich die Temperatur Ã¼ber kurze ZeitrÃ¤ume oft nur wenig verÃ¤ndert. Temperatur Ã¤ndert sich langsam.", correct = TRUE,
         message = "Genau â€“ das ist eine typische kurzfristige AbhÃ¤ngigkeit."),
  answer("Weil die Jahreszeiten sich tÃ¤glich Ã¤ndern", message = "Nein, das wÃ¤re saisonale VerÃ¤nderung, nicht tÃ¤gliche Schwankung.")
)
```

Zu jedem Lag (also jeder zeitlichen Verschiebung) einer Zeitreihe gehÃ¶rt ein Autokorrelationskoeffizient. Diese einzelnen Koeffizienten ergeben zusammen die Autokorrelationsfunktion (ACF), die angibt, wie stark eine Zeitreihe mit ihren verzÃ¶gerten Versionen zusammenhÃ¤ngt.

```{r}
selectInput("stadt_acf", "StÃ¤dte auswÃ¤hlen:",
                   choices = unique(all_temp$city),
                   selected = "Hanoi")
```


```{r}
output$acf_plot <- renderPlot({
  acf_plot_data <- all_temp %>%
  filter(city == input$stadt_acf) %>%
  arrange(date)
  
  acf(acf_plot_data$temperature, lag.max = 733, main = "Autokorrelation")
})
```

```{r}
plotOutput("acf_plot")
```

Die x-Achse zeigt den Lag (VerzÃ¶gerung in Tagen). Die y-Achse zeigt den Autokorrelationswert zwischen dem aktuellen Wert und dem um k Tage verschobenen Wert. Die schwarzen Balken zeigen die Korrelation bei jedem Lag.

- Hohe Korrelation bei kleinen Lags (z.B. Lag = 1â€“30)
zeigt, dass aufeinanderfolgende Tage Ã¤hnliche Temperaturen haben (kurzfristige AbhÃ¤ngigkeit).

- WellenfÃ¶rmiges Muster
deutet auf eine regelmÃ¤ÃŸige Wiederholung hin.

- Korrelation steigt etwa bei Lag = 365 (1 Jahr) und Lag = 730 (2 Jahre) erneut stark an
klarer Hinweis auf eine jÃ¤hrliche SaisonalitÃ¤t.



___
Dieselben Plots wie zuvor wurden unten gezeigt, diesmal jedoch auf monatlicher Basis statt tÃ¤glich.

ğŸ” Dadurch wird die jÃ¤hrliche SaisonalitÃ¤t noch deutlicher sichtbar:


```{r}
selectInput("stadt_", "StÃ¤dte auswÃ¤hlen:",
                   choices = unique(all_temp$city),
                   selected = "Hanoi")
```

```{r}
output$lag_monthly <- renderPlot({
  df <- all_temp %>%
    filter(city == input$stadt_) %>%
    mutate(
      date = as.Date(date),
      year = lubridate::year(date),
      month = lubridate::month(date)
    ) %>%
    group_by(year, month) %>%
    summarise(temp = mean(temperature, na.rm = TRUE), .groups = "drop") %>%
    filter(!is.na(temp)) %>%
    arrange(year, month)

  ts_temp <- ts(df$temp, frequency = 12, start = c(min(df$year), min(df$month)))

  lag.plot(ts_temp, lags = 12, do.lines = FALSE,
           main = paste("Lag Plot: Monatliche Temperatur in", input$stadt))
})


output$acf_monthly <- renderPlot({
  df <- all_temp %>%
    filter(city == input$stadt_) %>%
    mutate(
      date = as.Date(date),
      year = lubridate::year(date),
      month = lubridate::month(date)
    ) %>%
    group_by(year, month) %>%
    summarise(temp = mean(temperature, na.rm = TRUE), .groups = "drop") %>%
    filter(!is.na(temp)) %>%
    arrange(year, month)

  ts_temp <- ts(df$temp, frequency = 12)
  acf(ts_temp,
      lag.max = 12,
      main = paste("ACF: Monatliche Temperatur in", input$stadt_),
      xaxt = "n")
  
  axis(1,
       at = 0:12 / 12,
       labels = 0:12,
       las = 1) 
})


```

```{r}
plotOutput("lag_monthly")
```

Im Lag-Plot erkennst du bei Lag = 12 (ein Jahr Abstand) eine starke Punktwolke entlang der Diagonale.

```{r}
plotOutput("acf_monthly")
```

Im ACF-Plot zeigt sich ein starker Peak bei Lag = 12. Das bedeutet ein klares Signal fÃ¼r eine Jahreszyklenstruktur.

## Zusammenfassung

#### ğŸ§  Quizfragen zur Wiederholung


```{r wh_question}
question("Welche Bestandteile kann eine Zeitreihe enthalten?",
  answer("Trend, SaisonalitÃ¤t, Rest", correct = TRUE),
  answer("Mittelwert, Median, Modus", message = "Das sind statistische MaÃŸe, aber keine Komponenten einer Zeitreihe."),
  answer("Nur SaisonalitÃ¤t", message = "Es gibt meist mehr als nur ein saisonales Muster."),
  allow_retry = TRUE
)
```

```{r wh_question_2}
question("Warum ist das einfache LÃ¶schen von NAs problematisch?",
  answer("NAs stÃ¶ren nur die Grafik", message = "Das ist ein Nebeneffekt, aber nicht das Hauptproblem."),
  answer("NAs sind immer zufÃ¤llig", message = "Nicht unbedingt, sie kÃ¶nnen systematisch fehlen."),
   answer("Es kann wichtige ZeitbezÃ¼ge zerstÃ¶ren", correct = TRUE),
  allow_retry = TRUE
)
```


```{r wh_question_3}
question("Was passiert mit der Trendlinie, wenn das Fenster (moving average) grÃ¶ÃŸer wird?",
  answer("Sie wird glatter", correct = TRUE),
  answer("Sie folgt den Datenpunkten genauer", message = "Im Gegenteil: sie reagiert langsamer."),
  answer("Die Saison wird verstÃ¤rkt", message = "GlÃ¤ttung entfernt oft saisonale Muster."),
  allow_retry = TRUE
)
```

```{r wh_question_4}
question("Wie kann man die LÃ¤nge einer SaisonalitÃ¤t erkennen?",
  answer("Nur mit Mittelwerten", message = "Mittelwerte zeigen keine Wiederholung Ã¼ber Zeit."),
  answer("Durch Entfernen des Trends", message = "Das hilft, ist aber nicht allein ausreichend."),
  answer("Mit ACF und Lag-Plot", correct = TRUE),
  allow_retry = TRUE
)
```

```{r wh_question_5}
question("Wann ist ein additives Modell besonders sinnvoll?",
  answer("Wenn die SaisonalitÃ¤t zunimmt mit dem Trend", message = "Das wÃ¤re ein Fall fÃ¼r ein multiplikatives Modell."),
  answer("Wenn die Komponenten unabhÃ¤ngig sind", correct = TRUE),
  answer("Wenn keine SaisonalitÃ¤t vorliegt", message = "Dann braucht man keine Modellierung."),
  allow_retry = TRUE
)
```

```{r wh_question_6}
question("Was bedeutet ein starker Peak bei Lag = 12 in der ACF monatlicher Temperaturdaten?",
  answer("Es gibt eine jÃ¤hrliche SaisonalitÃ¤t", correct = TRUE),
  answer("Die Daten sind unkorreliert", message = "Ein starker Peak spricht *fÃ¼r* eine Korrelation."),
  answer("Es gibt nur eine lineare AbhÃ¤ngigkeit", message = "Lag-Korrelationen kÃ¶nnen auch nichtlinear sein."),
  allow_retry = TRUE
)
```

___
### ğŸ§  Was du gelernt hast

| Thema                      | Inhalt                                                               |
|---------------------------|----------------------------------------------------------------------|
| ğŸ“ˆ **Zeitreihe verstehen** | Datenpunkte Ã¼ber die Zeit hinweg analysieren                         |
| ğŸ“‰ **Trend erkennen**      | Langfristige Entwicklungen sichtbar machen                           |
| ğŸ” **SaisonalitÃ¤t**         | Wiederkehrende Muster wie Jahreszeiten oder                          |
| âš™ï¸ **STL-Zerlegung**        | Aufspaltung in Trend, Saison und Rest mit flexibler Zerlegungsmethode |
| ğŸ“Š **Autokorrelation**      | AbhÃ¤ngigkeit eines Werts von vorherigen Zeitpunkten (Lag)            |
| â— **Umgang mit NAs**        | Fehlende Werte identifizieren und sinnvoll ersetzen (z.â€¯B. Mittelwert) |

```{r}
wellPanel(
  h4("ğŸ§¾ Entscheidungs-Checkliste"),
  tags$ul(
    tags$li("ğŸ”½ Trend: Sinkt die Temperatur zu deinem Reisezeitpunkt? âœ… / âŒ"),
    tags$li("ğŸ” SaisonalitÃ¤t: Zeigt sich ein mildes Jahresmuster? âœ… / âŒ"),
    tags$li("ğŸ”º Extreme: Gibt es viele AusreiÃŸer oder Hitzespitzen? âœ… / âŒ"),
    tags$li("ğŸ“† Passender Monat: Gibt es angenehme Temperaturphasen? âœ… / âŒ"),
    tags$li("ğŸ“ Ortsvergleich: Ist der Ort stabiler als die Alternativen? âœ… / âŒ")
  )
)
```

"Welcher Ort und welcher Zeitraum wÃ¤ren deiner Meinung nach am angenehmsten fÃ¼r die Reise â€“ und warum?"

::: summary
ğŸ“ Fazit


âœˆï¸ Du hast gelernt, wie man mit Hilfe von Zeitreihendaten eine fundierte, datengestÃ¼tzte Entscheidung trifft.
ğŸ“Š Dieses Wissen kannst du nicht nur fÃ¼r Reisen nutzen, sondern fÃ¼r viele zeitabhÃ¤ngige Probleme von Klima Ã¼ber Energie bis Wirtschaft.
:::

